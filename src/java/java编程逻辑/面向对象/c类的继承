[引言]
    现实生活中的概念间还有一种非常重要的关系,就是分类.分类有个根,然后向下不断细化,形成一个层次分类体系.
    计算机程序经常使用类之间的'继承'关系来表示对象之间的分类关系.
    使用继承一方面可以复用代码,公共的属性和行为可以放到父类中,而子类只需要关注子类特有的就可以了;另一方面,不同子类的对象可以更方便地被统一管理

[4.1 基本概念]
    在java中,所有的类都有一个父类,object类
    [根父类Object]
        在java中即使没有声明父类,也有一个隐含的父类,这个父类叫做Object.Object没有定义属性,但是定义了方法.
        在Object中的方法:
            equals():boolean
            getClass():Class<?>
            hashCode():int
            notify():void
            notifyAll():void
            toString():String
            wait():void
            wait(long timeout):void
            wait(long timeout,int nanos):void
        通过toString()方法打印出'Point@76f9aa66'这个结果,后边的数值是哈希值,通常表示对象的内存地址,使用hashCode()方法
    [方法重写]
        通过@override来重写父类中的方法,例如toString等方法是来自Object的,所以没有extend
    [图形类继承体系]
        java使用extends关键字表示继承关系,一个类最多只能有一个父类
        子类不能直接访问父类的私有属性和方法
        除了私有外,子类继承了父类的其他属性和方法
        [super]
            super这个关键字,用于指代父类,可用于调用父类的构造方法,访问父类方法和变量
            调用父类构造方法时,super必须放在第一行
        子类对象赋值给父类引用变量,这叫向上转型,转型就是转换类型,向上转型就是转换为父类类型.
        一种类型的变量,可引用多种实际类型对象.
        [向上转型]
            子类对象赋值给父类引用变量,这叫向上转型,转型就是转换类型,向上转型就是转换为父类类型.
        [多态]
        变量shape可以引用任何Shape子类类型的对象,这叫多态,即一种类型的变量,可引用多种实际类型对象.
        这样,对于变量shape,它就有两个类型:
        类型Shape,我们称之为[shape的静态类型].
        类型Circle/Line/ArrowLine,我们称之为[shape的动态类型].
        在ShapeManager的draw方法中,shapes[i].draw()调用的是其对应动态类型的draw方法,
        这称之为[方法的动态绑定].
        [小结]
            多态和动态绑定是计算机程序的一种重要思维方式,使得操作对象的程序不需要关注对象的实际类型,从而可以统一处理不同对象,但又能实现每个对象的特有行为.
        1.每个类有且只有一个父类,没有声明父类的,其父类为Object,子类继承了父类非private的属性和方法,可以增加自己的属性和方法,以及重新父类的实现方法
        2.new过程中,父类先进行初始化,可通过super调用父类相应的构造方法,没有使用super的情况下,调用父类默认的构造方法
        3.子类变量和方法与父类重名的情况下,可通过super强制访问父类的变量和方法
        4.子类对象可以赋值给父类引用变量,这叫多态;实际执行调用的是子类实现,这叫动态绑定

[4.2 继承的细节]
    下面逐个介绍
    [构造方法]
        子类可以通过super调用父类的构造方法,如果子类没有通过super调用,则会自动调动父类默认的构造方法.
        例子:
        public class Base {
                    private String member;
                    public Base(String member){
                    this.member = member;
                    }
                }
                这个类只有一个带参数的构造方法,没有默认构造方法.这个时候它的任何子类都必须在构造方法中通过super调用Base的带参数构造方法,如下所示:
                public class Child extends Base{
                    public Child(String){
                        super(member);
                    }
                }
        另外,在父类构造方法中调用可被子类重写的方法,是一种不好的实践,容易混淆,不推荐使用.
    [重名与静态绑定]
        子类可以重写父类非private的方法,当调用的时候,会动态绑定,执行子类的方法.
        [重名]
            实例变量,静态方法,静态变量(类方法,类变量)都是可以重名的,重名后实际上有两个变量或方法.
            @@@重名的private变量和方法:
                重名的private变量和方法只能在类内访问,访问的也永远是当前类的
            @@@重名的public变量和方法:
                在类内:
                重名的public变量和方法访问的是当前类的,但子类可以通过super.明确指定访问父类的.
                    解释:
                        子类定义了和父类重名的方法和变量.对于一个子类对象,它就有两份变量和方法
                        ,在子类内部访问的时候,访问的是子类
                        ,或者说,子类变量和方法隐藏了父类对应的变量和方法
                在类外:
                则要看访问变量的静态类型
                    静态类型是父类,则访问父类的变量和方法
                    静态类型是子类,则访问子类的变量和方法
                    解释:
                        创建一个子类对象,然后将对象分别赋值给了子类引用变量c和父类引用变量b,然后通过b和c分别引用变量和方法.
                        [静态绑定]
                        当通过b(静态类型Base)访问时,访问的是Base的变量和方法
                        当通过c(静态类型Child)访问时,访问的是Child变量和方法
                        这称之为静态绑定,即访问绑定到变量的静态类型
        [动态绑定与静态绑定]                
        静态绑定在程序编译阶段即可决定,而动态绑定则要等到程序运行时
        实例变量,静态变量,静态方法,private方法,都是静态绑定的
    [重载和重写]
        @@@重载:是指一个类中方法名称相同但参数签名不同(参数个数,类型或顺序不同)
        @@@重写:是指子类重写与父类相同参数签名的方法
            当有多个重名函数的时候,在决定要调用哪个函数的过程中,首先是按照参数类型进行匹配的
            换句话说,寻找在所有重载版本中最匹配的,然后才看变量的动态类型,进行动态绑定
    [父子类型转换(向下转型)]
        语法上可以进行强制类型转换,但不一定能转换成功.
        一个父类的变量能不能转换为一个子类的变量,取决于这个父类的动态类型(即引用的对象类型)是不是这个子类或这个子类的子类
        [instanceof关键字]
        给定一个父类的变量能不能知道它到底是不是某个子类的对象,从而安全地进行类型转换?
        答案是可以的,通过instanceof关键字,instanceof前面是变量,后面是类,返回值是boolean值
        表示变量引用的对象是不是该类或其他子类的对象
    [继承访问权限protected]
        变量和函数有public/private修饰符
        public表示外部可以访问
        private表示只能内部使用
        protected表示不能被外部任意访问,但可被子类访问
        protected还表示可被同一个包中的其他类访问,不管其他类是不是该类的子类
        [模板方法]
            基类定义了表示对外行为的方法action,并定义了可以被子类重写的两个步骤step1()和step2()
            以及被子类查看的变量currentStep,子类通过重写protected方法step1()和step2()来修改对外的行为.
            这种设计是一种设计模式,称之为模板方法.
            action方法就是一个模板方法,它定义了实现的模板,而具体实现则由子类提供.
            模板方法在很多框架中有广泛的应用,这是使用protected的一种常见的场景
    [可见性重写]
        重写方法时,一般并不会修改方法的可见性.
        重写时,子类方法不能降低父类方法的可见性.
        '不能降低'是指,父类如果是public,则子类必须也是public,父类如果是protected,子类可以是protected,也可以public
        即子类可以升级父类方法的可见性但不能降低
        [为什么要这么规定?]
            继承反映的是"is-a"的关系,即子类对象也属于父类
            子类必须支持父类所有对外的行为,将可见性降低就会减少子类对外的行为
            而破坏"is-a"的关系,但子类可以增加父类的行为,所以提升可见性是没问题的
    [防止继承final]
        继承是把双刃剑,带来的影响就是,有的时候我们不希望父类方法被子类重写,
        有的时候甚至不想被继承,所以可以通过final关键字实现
        final关键字可以修饰变量,而这是final的另一种用法
        
        
[4.3 继承实现的基本原理]
        