[引言]
    之前介绍的基本类型/类/接口/枚举都是表示和操作数据,操作的过程中可能有很多错误的情况
    出错的原因可能是多方面的
    有的是不可控的内部原因,比如内存不够,磁盘满了
    有的不可控的外部原因,比如网络连接问题
    可能是程序的编写错误,比如引用变量未初始化就直接调用实例方法
 
    
[6.1 初始异常]
    两个具体异常:
        NullPointException和NumberFormatException
    [NullPointException(空指针异常)]
            代码例子如下:
                public class ExceptionTest{
                    public static void main(String[] args){
                        String s = null;
                        s.indexOf("a");
                    }
                }
        [空指针分析如下]
            当执行s.indexOf("a")的时候,Java虚拟机发现s的值为null,没有办法继续执行了
            这时启用异常处理机制,首先创建一个异常对象,这里是类NullPointException的对象
            然后查找谁能处理这个异常,在示例代码中,没有代码能处理这个异常
            因此Java启用默认处理机制,即打印异常栈信息到屏幕上,并退出程序.
    [NumberFormatException(数字格式异常)]
        new NumberFormatException是容易理解的,含义就是创建一个类的对象,只是这个类是一个异常类
        throw是什么意思呢?就是抛出异常,它会触发Java的异常处理机制
        在之前的空指针,我们没有看到throw的代码,可以认为throw是由Java虚拟机自己实现的
        [throw和return对比]
            return代表正常退出,throw代表异常退出
            return的返回位置是确定的,就是上一级调用者
            throw后执行哪行代码则经常是不确定的,由异常处理机制动态确定
            [异常处理机制]
            异常处理机制会从当前函数开始查找看谁"捕获"了这个异常,当前函数没有就查看上一层
            直到主函数为止,如果主函数也没有,就是用默认机制,即输出异常栈信息并退出
            [捕获]
            "捕获"是指try/catch捕获并处理了异常,捕获异常后,程序就不会异常退出了
            但try语句内异常点之后的其他代码就不会执行了,执行完catch内的语句后
            程序会继续执行catch花括号外的代码
            
            
[6.2 异常类]
    所有异常类都有一个共同的父类Throwable
    [Throwable]
        Throwable类有两个主要的参数:
            message,表示异常消息
            cause,表示触发该异常的其他异常
        异常可以形成一个异常链,上层异常由底层异常触发,cause表示底层异常
        Throwable还有一个public方法用于设置cause
        Throwable有一些常用的方法用于获取异常信息,如下:
            ...
    [异常类体系]
        Throwable是所有异常的基类,它有两个子类:Error和Exception
        Error表示系统错误或资源耗尽,由Java系统自己使用,应用程序不应抛出和处理
        Exception表示应用程序错误,它有很多子类,应用程序也可以通过继承Exception或其他子类创建自定义异常
        [RuntimeException]
            比较特殊,实际含义为[未受检异常],相对而言,Exception的其他子类和Exception自身则是受检异常
            Error及其子类也是未受检异常
        [受检异常与未受检异常的区别]
            区别在于Java如何处理这两个异常.对于受检异常,Java会强制要求程序员进行处理,否则会编译错误
            而对于未受检异常则没有这个要求
    [自定义异常]
        一般是继承Exception或者它的某个子类
        如果父类是RuntimeException或它的某个子类,则自定义异常也是未受检异常
        如果Exception或Exception的其他子类,则自定义异常是受检异常
        
        
[6.3 异常处理]
    java语言对异常处理的支持
        [catch匹配]
            异常处理机制将根据抛出的异常类型找第一个匹配的catch块,找到后,执行catch块内的代码,不再执行其他代码块
            抛出的异常类型是catch中声明异常的子类也算匹配
        [重新抛出异常]
            在catch块内处理完后,可以重新抛出异常,异常可以是原来的,也可以是新建的
            为什么要重新抛出异常?
                因为当前代码不能够完全处理异常,需要调用者进一步处理.
            为什么要抛出一个新的异常?
                当然是因为当前异常不太合适.
                不合适可能是信息不够,需要补充一些新信息;
                不合适还可能是过于细节,不便于调用者理解和使用
                如果调用者对细节感兴趣,还可以通过getCause()获取异常
        [finally]
            异常机制中还有一个重要的部分,就是finally
            catch后面可以跟finally语句
            [总结来说]
                finally内的代码不管有无异常发生,都会执行
                如果没有异常发生,在try内的代码执行结束后执行
                如果有异常发生且被catch块捕获,在catch内的代码执行结束后执行
                如果有异常发生但没被捕获,则在异常被抛给上层之前执行
            [finally执行顺序的特点]
                由于finally的这个特点,它一般用于释放资源,如数据库连接,文件流等
            [在try/catch中有return]    
                finally语句还有一个执行细节,如果在try或者catch语句内有return语句
                则return语句在finally语句执行结束后才执行,但finally并不能改变返回值
            [在finally中有return]
                try/catch内的return会丢失,实际会返回finally中的返回值.
                finally中有return不仅会覆盖try/catch内的return的返回值,还会掩盖try/catch内的异常,就像异常没有发生一样
                就算try/catch中触发异常,但是finally中有return语句,会覆盖,而不再向上传递异常了
                finally中,如果finally中抛出异常,则原异常也会被掩盖
        [try-with-resource]
            对于一些使用资源的场景,比如文件和数据库连接,典型的使用流程是首先打开资源
            最后在finally语句中调用资源的关闭方法
            资源可以在try语句外被声明和初始化,但必须是final的或者是事实上final的
            (即虽然没有声明为final但也没有被重新赋值)
        [throws]
            异常机制中,还有一个和throw很像的关键字throws,用于声明一个方法可能抛出的异常
            [throws声明异常]
                throws跟在方法的括号后面,可以声明多个异常,以逗号分隔.
                这个声明的含义是,这个方法内可能抛出这些异常,且没有对这些异常进行处理
                至少没有处理完,调用者必须进行处理
            [throws关于未受检异常的声明]
                对于未受检异常,是不要求使用throws进行声明的
            [throws关于受检异常的声明]
                但是对于受检异常,则必须进行声明,换句话说,如果没有声明,则不能抛出
                对于受检异常,不可以抛出而不声明,但可以声明抛出而实际不抛出
                主要是用于在父类方法中声明,父类方法内可能没有抛出,但子类重写方法后可能就抛出了
                子类不能抛出父类方法中没有声明的受检异常,所以就将所有可能抛出的异常都写到父类上
            如果一个方法内调用了另一个声明抛出受检异常的方法,则必须处理这些受检异常
            处理方式既可以是catch,也可以继承使用throws
        [对比受检异常和未受检异常]
            通过以上介绍可以看出,受检异常和未受检异常的区别如下:
            受检异常必须出现在throws语句中,调用者必须处理,Java编译器会强制这一点
            未受检异常则没有这个要求
            [一种普遍的观点]
                其中
                [未受检异常]
                未受检异常表示编程的逻辑错误
                    编程时应该检查以避免逻辑错误,比如空指针异常,如果真的出现了这些异常,程序退出也是正常的
                    程序员应该检查程序代码的bug而不是想办法处理这种异常
                [受检异常]
                受检异常表示程序本身没有问题
                    但由于I/O,网络,数据库等其他不可预测的错误导致的异常,调用者应该进行适当处理
                    其实编程错误也是应该进行处理的,尤其是Java被广泛应用于服务器程序中
                    不能因为一个逻辑错误就使程序退出
            [基本观点]
                无论是受检异常还是未受检异常,无论是否出现在throws声明中,都应该在适合的地方以适当的方式处理
                
                
[6.4 如何使用异常]
    针对异常,我们介绍了try/catch/finally , catch匹配,重新抛出,throws,受检/未受检异常,那到底该如何使用异常?
    [异常应该且仅用于异常情况]          
        异常应该且仅用于异常情况,是指异常不能代替正常的条件判断
        [例子]
            循环处理数组元素的时候,应该先检查索引是否有效再进行处理,而不是等着抛出索引异常再结束循环
            对于一个引用变量,如果正常情况下它的值也可能为null,那就应该先是不是null,不为null的情况下
        真正出现异常的时候,应该抛出异常,而不是返回特殊值
        纯技术上一种可能的替代方法是不抛出异常而返回特殊值null,但无效是异常情况,异常不能作为正常处理
    [异常处理的目标]
        异常大概可以分为三种来源:用户,程序员,第三方
            用户:是指用户的输入有问题
            程序员:是指编程错误
            第三方:泛指其他情况,如I/O错误,网络,数据库,第三方服务等
            每种异常都应该进行适当的处理
        [异常处理的目标]
        处理的目标可以分为恢复和报告
            恢复:是指通过程序自动解决问题
            报告:报告的最终对象可能是用户,即程序使用者,也可能是系统运维人员或程序员
                报告的目的也是为了恢复,但这个恢复经常需要人的参与
        [小结]
            对用户,如果用户输入不对,可以提示用户具体哪里输入不对,如果是编程错误,可以提示用户系统错误
        建议联系客服,如果是第三方连接问题,可以提示用户稍后重试.
            对系统运维人员或程序员,他们一般不关心用户输入错误,而关注编程错误或第三方错误,对于这些错误,
        需要报告尽量完整的细节,包括异常链,异常栈等,以便尽快定位和解决问题
            用户输入或编程错误一般都是难以通过程序自动解决的,第三方错误则可能可以,甚至很多时候,
        程序都不应该假定第三方是可靠的,应该有容错机制,比如,某个第三方服务器连接不上(比如发短信),
        可能的容错机制是换另一个提供同样功能的第三方试试,还可能是间隔一段时间进行重试,在多次失败之后再报告错误
    [异常处理的一般逻辑]
        如果自己知道怎么处理异常,就进行处理;
        如果可以通过程序自动解决,就自动解决;
        如果异常可以被自己解决,就不需要再向上报告;
        如果自己不能完全解决,就应该向上报告;
        如果自己有额外信息可以提供,有助于分析和解决问题,就应该提供,可以以原异常为cause重新抛出一个异常
        总有一层代码需要为异常负责,可能是知道如何处理该异常的代码,可能是面对用户的代码,也可能是主程序
        如果异常不能自动解决,对于用户,应该根据异常信息提供用户能理解和对用户有帮助的信息
        对运维和开发人员,则应该输出详细的异常链和异常栈日志
        [小结]
            在有了异常机制后,程序的正常逻辑与异常逻辑可以相分离,异常情况可以集中进行处理
            异常还可以自动向上传递,不需要每层方法都进行处理,异常也不再可能被自动忽略
            处理异常情况的代码可以大大减少,代码的可读性,可靠性,可维护性也都可以得到提高
        
        
        
        
        
            
            
            
            
            
                