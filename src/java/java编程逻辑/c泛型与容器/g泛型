[引言]
容器类是基于泛型的,不理解泛型,就难以深刻理解容器类
[8.1 基本概念和原理]
之前我们一直强调数据类型的概念,Java有8种基本类型,可以定义类,相当于自定义数据类型,类之间还可以有组合和继承
提到接口,关心的不是类型,而是能力,针对接口和能力编程,不仅可以复用代码,还可以降低耦合,提高灵活性
泛型将接口的概念进一步延伸,"泛型"的字面意思就是广泛的类型
类,接口和方法代码可以应用于非常广泛的类型,代码与它们能够操作的数据类型不再绑定在一起
同一套代码可以用于多种数据类型,可以复用代码,降低耦合,增加可读性
    [一个简单泛型类]
    Pair就是一个泛型类,与普通类的区别体现在:
        类名后面多了一个<T>
        first和second的类型都是T
            [T是什么呢?]
            T表示参数类型,泛型就是类型参数化,处理的数据类型不是固定,而是可以作为参数传入
        [基本概念]
            需要看代码
        [基本原理]
            我们知道,Java有Java编译器和Java虚拟机,编译器将Java源代码转换为.class文件,
            虚拟机加载并行.class文件.
            对于泛型类,Java编译器会将泛型代码转换为普通的非泛型代码,
            就像上面的普通Pair类代码及其使用代码一样,将类型参数T擦除,替换为Object,插入必要强制类型转换.
            Java虚拟机实际执行的时候,它是不知道泛型这个事儿,只知道普通的类及代码.
            [强调]
                Java泛型是通过擦除实现的,类定义中的类型参数如T会被替换为Object,
                在程序运行过程中,不知道泛型的实际类型参数,
                比如Pair<Integer>,运行中只知道Pair,而不知道Integer.
        [泛型的好处]
            既然使用普通类和Object就可以,而且泛型最后也转换为了普通类
            [泛型的两个好处]
                @@@更好的[安全性]:
                    安全性就是说用Object的时候,进行强制类型转换,即使使用类型错误,编译也不会错误
                    所以使用泛型可以有效解决这个问题
                更好的可读性
            语言和程序设计的一个重要目标是将bug尽量消灭在摇篮里,能消灭在写代码的时候,
            就不用等到代码写完程序运行的时候.
            [强调]
                开发环境会提示类型错误,即使没有好的开发环境,编译时Java编译器也会提示.
                这称之为类型安全,通过使用泛型,开发环境和编译器确保不会用错类型,为程序设置安全网
                使用泛型,可以省去强制类型转换,再加上明确的类型信息,代码可读性也会更好
    [容器类]
        泛型类最常见的用途是作为容器类.所谓容器类,简单地说,就是容纳并管理多项数据的类.
        数组就是用来管理多项数据的,但数组有很多限制,比如,长度固定,插入,删除操作效率比较低.
        这些数据结构在Java中的实现主要就是Java中的各种容器类,
        甚至Java泛型的引入主要也是为了更好的支持Java容器.
            [动态数组]
                动态数组,就是长度可变的数组.
                底层数组的长度当然是不可变,但我们提供一个类,对这个类的使用者而言,
                好像就是一个长度可变的数组
        DynamicArray就是一个动态数组,内部代码与我们之前分析过的StringBuilder类似,
        通过ensureCapacity方法来根据需求扩展数组.
        作为一个容器类,它容纳的数据类型是作为参数传递过来的
    [泛型方法]
        除了泛型类,方法也可以是泛型的
    [泛型接口]
        接口也可以是泛型的,我们之前介绍过的Comparable和Comparator接口都是泛型
    [类型参数的限定]
    无论是泛型类,泛型方法还是泛型接口
        [上界为某个具体类]
        限定类型后,就可以使用该类型的方法.比如,对于NumberPair类,
        first和second变量就可以当做Number进行处理
        限定类型后,如果类型使用错误,编译器会提示.
        指定边界后,类型擦除时就不会转换为Object类,而会转换为边界类型
        [上界为某个接口]
        max方法计算一个泛型数组中的最大值.计算最大值需要进行元素之间的比较,要求元素实现Comparable接口
        所以给类型参数设置了一个上边界Comparable,T必须实现Comparable接口
        [上界为其他类型参数]
        Java支持一个类型参数以另一个类型参数作为上界
        其他类型参数使用E来表示,设置限定上界
    [小结]
    泛型是计算机程序中一种重要的思维方式,它将数据结构和算法与数据类型相分离,
    使得同一套数据结构和算法能够应用于各种数据类型,而且可以保证类型安全,提高可读性
    在Java中,泛型广泛应用于各种容器中,理解泛型是深刻理解各种容器的基础
    在Java中,泛型是通过类型擦除来实现的,它是Java编译器的概念,Java虚拟机运行时对泛型基本一无所知
    
    
[8.2 解析通配符]
    讨论泛型中通配符的概念
    [更简洁的参数类型限定]
    例子:
        public void addAll(DynamicArray<? extends E> c){
            for(int i = 0;i<c.size; i++){
                add(c.get(i));
            }
        }
        这个方法没有定义类型参数,c的类型是DynamicArray<? extends E> ,其中?表示通配符,
        <? extends E> 表示有限定通配符,匹配E或E的某个子类,具体什么子类型是未知的
    @@@个人理解:就是相当于定义了上限类型,不固定哪一个子类,便于复用
        [<T extends E>和<? extends E>的区别何在?]
            1.<T extends E>用于定义类型参数,它声明了一个类型参数T,
            可放在泛型类定义中类名后面,泛型方法返回值前面
            2.<? extends E>用于实例化类型参数,它用于实例化泛型变量中的类型参数,
            只是这个具体类型是未知的,只知道它是E或E的某个子类
    [理解通配符]
        例子:
        这个写法:
            public static int indexOf(DynamicArray ?  arr,Object elm)
        可以改为:
            public static <T> int indexOf(DynamicArray<T> arr ,Object elm)
            可以比较出,使用通配符更为简洁,但上面的通配符有一个重要的限制:只能读,不能写
            [为什么只能读,不能写呢?]
            问号就是表示类型安全无知, ? extends Number表示是Number的某个子类型,
            但不知道具体子类型,如果允许写入,Java就无法确保类型安全性,所以干脆禁止
            [总结]
            1.通配符形式都可以用类型参数的形式来替代,通配符能做的,用类型参数也能做
            2.通配符形式可以减少类型参数,形式上往往更为简单,可读性也更好,所以能有通配符就用通配符
            3.如果类型参数之间有依赖关系,或者返回值依赖类型参数,或者需要操作,则只能用类型参数
            4.通配符形式和类型参数往往配合使用,比如,上面的copy方法,定义必要的类型参数,
            使用通配符表达依赖,并接受更为广泛的数据类型
    [超类型通配符]
    形式为<? super E>
    称为超类通配符,表示E的某个父类.表示该类的下界
    (关于child和base的比较,看完以后并不是很明白,但是想到通配符的含义,?有一个更为深刻的理解,
    理解的含义就是,使用了通配符相当于带一个搜索匹配的功能)
    [通配符比较]
    泛型中三种通配符形式,?   ;   ? extends E   和   ? super E
        1.他们的目的都是为了使方法接口更为灵活,可以接受更为广泛的类型
        2.? super E [用于灵活写入或比较],使得对象可以写入父类型的容器,使得父类型的比较方法可以
          应用于子类对象,它不能被类型参数形式替代
        3.? extends E 和 ? [用于灵活读取],使得方法可以读取E或E的任意子类的容器对象,
          它们可以用类型参数的形式替代,但通配符形式更为简洁
    
    
    
[8.3 细节和局限性]
Java中,泛型是通过类型擦除来实现的,类型参数在编译时会被替换成Object,运行时Java虚拟机不知道泛型,
这带来很多局限性.
一项技术,往往只有理解了其局限性,才算是真正理解了它,才能更好的应用它.
    [使用泛型类,方法和接口]
        三个注意点:
            1.基本类型不能用于实例化类型参数
            2.运行时类型信息不适用于泛型
            3.类型擦除可能会引发一些冲突
            [基本类型不能用于实例化类型参数]
                Java中,因为类型参数会被替换为Object,所以Java泛型中不能使用基本数据类型
                基本的解决方法是使用基本类型对应的包装类
            [运行时类信息不适用于泛型]
                在介绍继承的实现原理,我们提到在内存中每个类都有一份类型信息,
                而每个对象也都保存着其对应类型信息的引用,这里简要说明一下,
                在Java中,这个类型信息也是一个对象,它的类型为Class,[Class本身也是一个泛型类]
                @@@每个类的类型信息可以通过 类名.class 的方式引用
                @@@这个类型对象也可以通过对象的 getClass() 方法获得
                @@@一个泛型对象的getClass方法的返回值与原始类型对象也是相同的
                同样的,
                instanceOf后面是接口或类名,instanceOf是运行时判断,也与泛型无关
                不过Java支持如下写法:
                    if ( p1 instanceOf Pair<?> )
                    就是使用通配符
            [类型擦除可能会引发一些冲突]
                接口不能被实现两次,且两次实现的类型参数还不同,一次是Comparable<Base>,
                一次是Comparable<Child>,为什么不允许?因为类型擦除后,实际只能有一个
                同样的,
                一个是DynamicArray<Integer>,另一个是DynamicArray<String>,在实例化时,
                类型擦除后的它们的声明是一样的
    [定义泛型类,方法和接口]
    三个注意点:
        不能通过类型参数创建对象
        泛型类类型参数不能用于静态变量和方法
        了解多个类型限定的语法
        [不能通过类型参数创建对象]
            类型擦除以后都是Object类型的对象,而无法创建T类型的对象,容易引起误解,所以Java禁止这么干
        [泛型类类型参数不能用于静态变量和方法]
            由于类型擦除,Singleton类型只有一份,静态变量和方法都是类型的属性,且与类型参数无关,
            所以不能使用泛型类类型参数
            对于静态方法,它可以是泛型方法,可以声明自己的类型参数,这个参数与泛型类的类型参数无关
        [了解铎哥类型限定的语法]
            Java支持多个上界,多个上界之间以&分隔,
            如果有上界类,类应该放在第一位,类型擦除时,会用第一个上界替换
    [泛型与数组]
    引入泛型后,发现,不能创建泛型数组
    比如,一个DynamicArray<Integer>对象不能赋值给一个DynamicArray<Number>变量,不过数组可以
    数组是Java类型支持的概念,它知道数组元素的实际类型,
    知道Object和Number都是Integer的父类型,所以这个操作是允许的
        [总结]
        Java不支持创建泛型数组
        如果要存放泛型对象,可以使用原始类型的数组,或者使用泛型容器
        泛型容器内部使用Object数组,如果要转换泛型容器为对应类型的数组,需要使用反射
    [小结]
    本节主要介绍泛型的一些细节和局限性,这些局限性主要是由于Java泛型的实现机制引起的,
    主要包括:
         不能是使用基本类型
         没有运行时类型信息
         类型擦除会引发冲突
         不能通过类型参数创建对象
         不能用于静态变量
    
    