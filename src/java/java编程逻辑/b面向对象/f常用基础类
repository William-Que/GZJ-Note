[7.1 包装类]
    每种基本类型都有一个对应的包装类.包装类是什么?它是一个类,内部有一个实例变量
    保存对应的基本类型的值,这个类一般还有一些静态方法,静态变量和实例方法,以方便对数据进行操作
    Java中很多代码只能操作对象,为了能操作基本类型,需要使用其对应的包装类
    [基本用法]
        将基本类型转换为包装类的过程,一般称为"装箱",而将包装类型转换为基本类型的过程,则称为"拆箱"
        Java 5以后使用自动装箱和拆箱技术
    [共同点]
        各个包装类有很多共同点,比如,都重写了Object中的一些方法,都实现了Comparable接口,都有一些与String
    有关的方法,大部分都定义了一些静态常量,都是不可变的
    [重写Object方法]
        所有包装类都重写了Object类
        [equals]
            equals用于判断当前对象和参数传入的对象是否相同,Object类的默认实现是比较地址
            对于两个变量,只有这两个变量指向同一个对象时,equals才反馈true,它和比较运算符(==)的结果是一样的
            [equals应该反映的是对象间的逻辑相等关系],所以这个默认实现一般是不合适的,子类需要重写该实现
        [hashCode]
            hashCode返回一个对象的返回值.
            哈希值是一个int类型的数,由对象中一般不变的属性映射得来,用于快速对对象进行区分,分组等
            一个对象的哈希值不能改变
            相同对象的哈希值必须一样
            不同对象的哈希值一般应不同,但这不是必需的,可以有对象不同但哈希值相同的情况
            [hashCode和equals()方法联系密切]
                对两个对象,如果equals方法返回true,则hashCode也必须一样
                反之不要求,equal方法返回false时,hashCode可以一样,也可以不一样,但应该尽量不一样
                hashCode的默认实现一般是将对象的内存地址转换为整数
                子类如果重写了equals()方法,也必须重写hashCode
        [Comparable]
            每个包装类都实现了Java API中的Comparable接口
            Comparable接口只有一个方法compareTo()
            当前对象与参数对象进行比较,在小于,等于,大于参数时,应分别返回-1,0,1
        [包装类和String]
            除了toString()方法外,包装类还有一些其他与String相关的方法
        [常用常量]
            包装类中除了定义静态方法和实例方法外,还定义了一些静态变量
        [Number]
            6种数值类型包装类有一个共同的父类Number
            Number是一个抽象类
        [不可变性]
            包装类都是不可变类
            所谓不可变是指实例对象一旦创建,就没办法修改了,通过如下方式强制实现:
                所有包装类都声明为了final,不能继承
                内部基本类型值是私有的,且声明为了final
                没有定义setter方法
            不可变使得程序更为简单安全,因为不用操心数据被意外改写的可能,可以安全地共享数据
    [剖析Integer与二进制算法]
        Integer有一些二进制操作,包括位翻转和循环移位,也需要分析valueOf实现
        [位翻转]
            Integer有两个静态方法,可以按位进行翻转
            位翻转就是将int当作二进制,左边的位与右边的位进行互换
            reserve是按位进行互换
            reserveBytes是按byte进行互换
            二进制可以在一条指令中交换多个相邻位
            reserve是在充分利用CPU的这些特性,并行高效地进行相邻位的交换
        [循环位移]
            Integer有两个静态方法,可以进行循环位移
            rotateLeft()方法是循环左移,rotateRight()方法是循环右移
            所谓循环位移,是相对于普通的位移而言的
        [valueOf的实现]
            创建包装类对象时,可以使用静态的valueOf方法,也可以直接使用new,但建议使用valueOf方法
            它使用了IntegerCache,这是一个私有静态内部类,
            IntegerCache表示Integer缓存,其中的cache变量是一个静态Integer数组
            在静态初始化代码块中被初始化
            默认情况下,保存了-128~127共256个整数对应的Integer对象
            在valueOf代码中,如果数值位于被缓存的范围,即默认-128~127
            则直接从Integer-Cache中获取已预先创建的Integer对象,只有不在缓存范围时,才通过new对象
            通过共享常用对象,可以节省内存空间,由于Integer是不可变的,所以缓存的对象可以安全地被共享
            Boolean,Byte,Short,Long,Character都由类似实现
            这种共享常用对象的思路,是一种常见的设计思路,它有一个名字为'享元模式'
    [剖析Character]
        Character类除了封装了一个char外,还有什么可以介绍呢?
        它有很多静态方法,封装了Unicode字符级别的各路操作
        [Unicode基础]
            Unicode给世界上每个字符分配了一个编号,编号范围:0x000000-0x10FFFF.
        [检查code point和char]
        ...
        [code point和char转换]
        ...
        [按code point处理char数组或序列]
        ...
        [字符属性]
        ...
        [字符转换]
        ...
        
        

[7.2 剖析String]
    Java中处理字符串的主要类是String和StringBuilder,本节主要介绍String
    [基本用法]
    可以通过常量定义String变量
    通过new创建String变量
    直接使用+和+=运算符
    [走进String内部]
    String内部用一个字符数组表示字符串,实例变量定义为:private final char value[];
    需要说明的是,String会根据参数新创建一个数组,并复制内容,而不会直接用参数中的字符数组.
    String中的大部分方法内部也都是操作的这个字符数组
        (1)length方法返回的是这个数组的长度
        (2)subString方法,调用构造方法String(char value[],int offset,int count)新建一个字符串
        (3)indexOf方法查找字符或子字符串时是在这个数组中进行查找
    [编码转换]
    ...
    [不可变性]
    与包装类类似,String类也是不可变类,即对象一旦创建,就没有办法修改了.
    String类也声明为了final,不能被继承,内部char数组value也是final的,初始化后就不能再变了.
    String类中提供了很多看似修改的方法,其实是通过创建新的String对象实现的,原来的String对象不会被修改
    与包装类类似,定义为不可变类,程序可以更为简单,安全,容易理解.
    但如果频繁修改字符串,而每次修改都新建一个字符串,那么性能太低
    应该考虑Java中的另两个类StringBuilder和StringBuffer
    [常量字符串]
    Java中的字符串常量是非常特殊的,除了可以直接赋值给String变量外,它自己就像一个String类型的对象
    实际上,这些常量就是String类型的对象,在内存中,它们被放在一个共享的地方,这个地方称为字符串常量池
    它保存了所有的常量字符串,每个常量只会保存一份,被所有使用者共享
    当通过常量的形式使用一个字符串的时候,使用的就是常量池中的那个对应的String类型的对象
    如果不是通过常量直接赋值,而是通过new创建,==就不会返回true了
    [hashCode]
    hash变量缓存了hashCode方法的值,第一次调用hashCode方法的时候,会把结果保存在hash这个变量中
    以后再调用就直接返回保存的值
    [正则表达式]
    一般用于文本的匹配,查找,替换等
    Java中有专门的类(如Pattern和Matcher)用于正则表达式
    
    
    
[7.3 剖析StringBuilder]
    如果字符串修改操作比较频繁,应该采用StringBuilder和StringBuffer类
    这两个类的方法基本是完全一样的
    这两个类唯一的不同在于StringBuffer类是线程安全的,而StringBuilder类不是
    [基本用法]
    大部分情况下
    通过new新建StringBuilder对象
    通过append方法添加字符串
    通过toString方法获取构建完成的字符串
    [基本实现原理]
    与String类似,StringBuilder类也封装了一个字符数组,定义如:char[] value;
    append会直接复制字符到内部的字符数组中,如果字符组长度不变,会进行扩展,实际使用的长度用count体现
        [扩展的逻辑是]
        分配一个足够长度的新数组,然后将原有的内容复制到这个新数组中,最后让内部的字符数组指向这个新数组
        [为什么要扩展]
        这是折中的策略,一方面减少内存分配的次数,另一方面要避免空间浪费
        在不知道最终需要多长的情况下,指数扩展是一种常见的策略,广泛应用于各种内存分配相关的计算机程序中
        这个实现思路:
            在确保有足够长度后,首先将原数组中offset开始的内容向后挪动n个位置
            n为待插入字符串的长度,然后将待插入字符串复制进offset位置
    [String的+和+=运算符]
    String可以直接使用+和+=运算符,这是Java编译器提供的支持
    背后,Java编译器一般会生成StringBuilder,+和+=操作会转换为append
    对于简单的情况,可以直接使用String的+ 和+= 
    对于复杂的情况,尤其是有循环的时候,应该直接使用StringBuilder
    
    
    
[7.4 剖析Arrays]
    数组是存储多个同类型元素的基本数据结构,数组中的元素在内存连续存放,可以通过数组下标直接定位任意元素
    [用法]
    主要介绍toString,排序,查找等
        [toString]
        可以直接调用
        [排序]
        sort方法有两个重载
        sort方法直接排序的基本数据类型
        sort方法中有匿名类Comparable接口用于对象排序
            [小结]
            传递比较器Comparator给sort方法,体现了程序设计中一种重要的思维方式
            将不变和变化相分离,排序的基本步骤和算法是不变的,但按什么排序是变化的
            sort方法将不变的算法设计为主体逻辑,而将变化的排序方式设计为参数
            允许调用者动态指定,这也是一种常见的设计模式,称为策略模式,不同的排序方式是不同的策略
        [查找]
        可以在已排序的数组中进行二分查找
        [更多方法]
        .
    [多维数组]
    多维数组只是一个假象,只有一维数组,只是数组中的每个元素还可以是一个数组
    [实现原理]
    ...
        [二分查找]
        ...
        [排序]
        对于排序没有,没有一个最好的算法,不同算法往往有不同的适用场合
        对于基本类型的数组,Java采用的算法是双枢轴快速排序
        对于对象类型,Java采用的算法是TimeSort
        [为什么基本类型和对象类型的算法不一样]
        排序算法有一个稳定性的概念,所谓稳定性就是对值相同的元素
        如果排序前和排序后,算法可以保证他们的相对顺序不变,那算法就是稳定的,否则就是不稳定的
        快速排序更块,但不稳定,而归并排序是稳定的
        对于基本类型,值相同就是完全相同,所以稳定不稳定没有关系
        但对于对象类型,相同只是比较结果一样,他们还是不同的对象,其他实例变量也不见得一样
        稳定不稳定可能就很有关系,所以才有归并算法
    [小结]
    ...
    
    
    
[7.5 剖析日期和时间]
    Java中日期和时间处理相关的API
    [基本概念]
    关于日期和时间,有一些基本概念,包括时区,时刻,纪元时,年历等
        [时区]
        不同具体时间与时区有关
        [时刻和纪元时]
        所有计算机系统内部都用一个整数表示时刻,这个整数是距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数
        [年历]
        ...
    [时期和时间API]
    Date:
        表示时刻,即绝对时间,与年月日无关
    Calendar:
        表示年历,Calendar是一个抽象类
    DateFormat:
        表示格式化,能够将日期和时间与字符串进行相互转换
        DateFormat是一个抽象类,最常用SimpleDateFormat
    TimeZone:
        表示时区
    Local:
        表示国家(或地区)和语言
        [Date]
        Date是Java API中最早引入的关于日期的类,但是过时了,有注解@Deprecated
        [TimeZone]
        TimeZone表示时区,它是一个抽象类,有静态方法用于获取其实例
        [Locale]
        Locale表示国家(或地区)和语言,它有两个参数:一个是国家,另一个是语言
        [Calendar]
        Calendar类是日期和时间操作的主要类
        [DateFormat]
        DateFormat类主要在Date和字符串表示之间进行相互转换
        format方法将Date转换为字符串,parse将字符串转换为Date
        DateFormat虽然比较方便,但如果我们要对字符串格式有更精确的控制,则应该使用SimpleDateFormat这个类
        [SimpleDateFormat]
        SimpleDateFormat是DateFormat的子类,相比DateFormat,它的一个主要不同是
        它可以接受一个自定义模式(pattern)作为参数,这个模式规定了Date的字符串形式
            [pattern方法的英文字符含义]
            yyyy:表示4位年
            MM:表示月
            dd:表示日
            HH:表示24小时制的小数
            mm:表示分数
            ss:表示秒
            E:表示星期几
    [局限性]
    ...
        [Date中的过时方法]
        ...
        [Calendar操作比较烦琐]
        ...
        [DateFormat的线程安全性]
        解决方案:
            每次使用DateFormat都新建一个对象
            使用线程同步
            使用ThreadLocal
            使用Joda-Time或Java 8 API ,他们是线程安全的
        
        
        
[7.6 随机]
    常见的需求
    [Math.random]
    Java中,对随机最基本的支持是Math类中的静态方法random(),它生成一个0-1的随机数,类型为double
    [Random]
    种子决定了随机产生的序列,种子相同,产生的随机数序列就是相同的
        Random rnd = new Random(20160824)
        for(int i = 0 ;i < 5 ; i++){
            syt.print(rnd.nextInt(100), " ");
        }
        种子为20160824,产生的5个0-100的随机数
        这个程序无论执行多上遍,都是输出相同的结果
        [为什么要指定种子?]
        指定种子是为了实现可重复的随机
    [随机的基本原理]
    Random产生的随机数不是真正的随机数,相反的,它产生的随机数一般称为伪随机数
    数学运算是固定的,所以种子确定以后,产生的随机数序列就是确定的,确定的数字序列当然不是真正的随机数
    随机数基于一个种子,种子固定,随机数序列就固定,默认构造方法中,种子是一个真正的随机数
        [线性同余随机数生成器]
        旧的种子(oldseed)乘以一个数(multipler),加上一个数addend,然后取低48位作为结果(mask相与)
    [随机密码]
    ...
    [洗牌]
    ...
    [带权重的随机选择]
    ...
    [抢红包算法]
    ...
    [北京购车摇号算法]
    ...
    [小结]
    Random类是线程安全的,多个线程可以同时使用一个Random实例对象,不过,如果并发性很高,会产生竞争
    可以考虑使用多线程库中的ThreadLocalRandom类
    
            
            
            
            
            
            
            
            
            
            
            
            