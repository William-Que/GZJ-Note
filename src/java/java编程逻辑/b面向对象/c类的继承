[引言]
    @现实生活中的概念间还有一种非常重要的关系,就是分类.分类有个根,然后向下不断细化,
    形成一个层次分类体系.
    计算机程序经常使用类之间的'继承'关系来表示对象之间的分类关系.
    @使用继承一方面可以复用代码,公共的属性和行为可以放到父类中,而子类只需要关注子类特有的就可以了,
    另一方面,不同子类的对象可以更方便地被统一管理

[4.1 基本概念]
    在java中,所有的类都有一个父类,object类
    [根父类Object]
        @在java中即使没有声明父类,也有一个隐含的父类,这个父类叫做Object.
        Object没有定义属性,但是定义了方法.
        在Object中的方法:
            equals():boolean
            getClass():Class<?>
            hashCode():int
            notify():void
            notifyAll():void
            toString():String
            wait():void
            wait(long timeout):void
            wait(long timeout,int nanos):void
        @通过toString()方法打印出'Point@76f9aa66'这个结果,后边的数值是哈希值
        通常表示对象的内存地址,使用hashCode()方法
    [方法重写]
        通过@override来重写父类中的方法,例如toString等方法是来自Object的,所以没有extend
    [图形类继承体系]
        java使用extends关键字表示继承关系,一个类最多只能有一个父类
        子类不能直接访问父类的私有属性和方法
        除了私有外,子类继承了父类的其他属性和方法
        [super]
            super这个关键字,用于指代父类,可用于调用父类的构造方法,访问父类方法和变量
            调用父类构造方法时,super必须放在第一行
        子类对象赋值给父类引用变量,这叫向上转型,转型就是转换类型,向上转型就是转换为父类类型.
        一种类型的变量,可引用多种实际类型对象.
        [向上转型]
            子类对象赋值给父类引用变量,这叫向上转型,转型就是转换类型,向上转型就是转换为父类类型.
        [多态]
        变量shape可以引用任何Shape子类类型的对象,这叫多态,即一种类型的变量,可引用多种实际类型对象.
        这样,对于变量shape,它就有两个类型:
        类型Shape,我们称之为[shape的静态类型].
        类型Circle/Line/ArrowLine,我们称之为[shape的动态类型].
        在ShapeManager的draw方法中,shapes[i].draw()调用的是其对应动态类型的draw方法,
        这称之为[方法的动态绑定].
        [小结]
            @多态和动态绑定是计算机程序的一种重要思维方式,使得操作对象的程序不需要关注对象的实际类型
            从而可以统一处理不同对象,但又能实现每个对象的特有行为.
        1.每个类有且只有一个父类,没有声明父类的,其父类为Object,子类继承了父类非private的属性和方法
        ,可以增加自己的属性和方法,以及重新父类的实现方法
        2.new过程中,父类先进行初始化,可通过super调用父类相应的构造方法,没有使用super的情况下
        ,调用父类默认的构造方法
        3.子类变量和方法与父类重名的情况下,可通过super强制访问父类的变量和方法
        4.子类对象可以赋值给父类引用变量,这叫多态;实际执行调用的是子类实现,这叫动态绑定

[4.2 继承的细节]
    下面逐个介绍
    [构造方法]
        子类可以通过super调用父类的构造方法,如果子类没有通过super调用,则会自动调动父类默认的构造方法.
        例子:
        public class Base {
                    private String member;
                    public Base(String member){
                    this.member = member;
                    }
                }
                这个类只有一个带参数的构造方法,没有默认构造方法.
                这个时候它的任何子类都必须在构造方法中通过super调用Base的带参数构造方法,如下所示:
                public class Child extends Base{
                    public Child(String){
                        super(member);
                    }
                }
        另外,在父类构造方法中调用可被子类重写的方法,是一种不好的实践,容易混淆,不推荐使用.
    [重名与静态绑定]
        子类可以重写父类非private的方法,当调用的时候,会动态绑定,执行子类的方法.
        [重名]
            实例变量,静态方法,静态变量(类方法,类变量)都是可以重名的,重名后实际上有两个变量或方法.
            @@@重名的private变量和方法:
                重名的private变量和方法只能在类内访问,访问的也永远是当前类的
            @@@重名的public变量和方法:
                在类内:
                重名的public变量和方法访问的是当前类的,但子类可以通过super.明确指定访问父类的.
                    解释:
                        子类定义了和父类重名的方法和变量.对于一个子类对象,它就有两份变量和方法
                        ,在子类内部访问的时候,访问的是子类
                        ,或者说,子类变量和方法隐藏了父类对应的变量和方法
                在类外:
                则要看访问变量的静态类型
                    静态类型是父类,则访问父类的变量和方法
                    静态类型是子类,则访问子类的变量和方法
                    解释:
                        创建一个子类对象,然后将对象分别赋值给了子类引用变量c和父类引用变量b,
                        然后通过b和c分别引用变量和方法.
                        [静态绑定]
                        当通过b(静态类型Base)访问时,访问的是Base的变量和方法
                        当通过c(静态类型Child)访问时,访问的是Child变量和方法
                        这称之为静态绑定,即访问绑定到变量的静态类型
        [动态绑定与静态绑定]                
        静态绑定在程序编译阶段即可决定,而动态绑定则要等到程序运行时
        实例变量,静态变量,静态方法,private方法,都是静态绑定的
    [重载和重写]
        @@@重载:是指一个类中方法名称相同但参数签名不同(参数个数,类型或顺序不同)
        @@@重写:是指子类重写与父类相同参数签名的方法
            当有多个重名函数的时候,在决定要调用哪个函数的过程中,首先是按照参数类型进行匹配的
            换句话说,寻找在所有重载版本中最匹配的,然后才看变量的动态类型,进行动态绑定
    [父子类型转换(向下转型)]
        语法上可以进行强制类型转换,但不一定能转换成功.
        一个父类的变量能不能转换为一个子类的变量,
        取决于这个父类的动态类型(即引用的对象类型)是不是这个子类或这个子类的子类
        [instanceof关键字]
        给定一个父类的变量能不能知道它到底是不是某个子类的对象,从而安全地进行类型转换?
        答案是可以的,通过instanceof关键字,instanceof前面是变量,后面是类,返回值是boolean值
        表示变量引用的对象是不是该类或其他子类的对象
    [继承访问权限protected]
        变量和函数有public/private修饰符
        public表示外部可以访问
        private表示只能内部使用
        protected表示不能被外部任意访问,但可被子类访问
        protected还表示可被同一个包中的其他类访问,不管其他类是不是该类的子类
        [模板方法]
            基类定义了表示对外行为的方法action,并定义了可以被子类重写的两个步骤step1()和step2()
            @以及被子类查看的变量currentStep,
            子类通过重写protected方法step1()和step2()来修改对外的行为.
            这种设计是一种设计模式,称之为模板方法.
            action方法就是一个模板方法,它定义了实现的模板,而具体实现则由子类提供.
            模板方法在很多框架中有广泛的应用,这是使用protected的一种常见的场景
    [可见性重写]
        重写方法时,一般并不会修改方法的可见性.
        重写时,子类方法不能降低父类方法的可见性.
        '不能降低'是指,父类如果是public,则子类必须也是public,父类如果是protected,
        子类可以是protected,也可以public
        即子类可以升级父类方法的可见性但不能降低
        [为什么子类可以升级父类方法的可见性但不能降低?(is-a)]
            继承反映的是"is-a"的关系,即子类对象也属于父类
            子类必须支持父类所有对外的行为,将可见性降低就会减少子类对外的行为
            而破坏"is-a"的关系,但子类可以增加父类的行为,所以提升可见性是没问题的
    [防止继承final]
        继承是把双刃剑,带来的影响就是,有的时候我们不希望父类方法被子类重写,
        有的时候甚至不想被继承,所以可以通过final关键字实现
        final关键字可以修饰变量,而这是final的另一种用法
        
        
[4.3 继承实现的基本原理]
    示例在代码中
    [类加载过程]
        在java 中,所谓类的加载是指将类的相关信息加载到内存.
        在java 中,类是动态加载的,当第一次使用这个类的时候,才会加载,加载一个类时,会查看其父类是否已经加载,如果没有,则会加载其父类
        [初始化默认值]
            数值变量是0,boolean类型是false,char类型是'\u0000',引用型变量是null
        @
        @@具体的详细过程没有看,留待下次攻破
        

[4.4 为什么说继承是把双刃剑]
    @@@继承为什么会有破坏力呢?
        主要是因为继承可能破坏封装,而封装可以说是程序设计的第一原则
        [什么是封装?]
            封装就是隐藏现实细节,提供简化接口.使用者只需要关注如何使用,而不需要关注内部是如何实现的.
        [继承可能会破坏封装的原因]
            子类和父类之间可能存在着实现袭击的依赖
            子类在继承父类的时候,往往不得不关注父类的实现细节
            而父类在修改其内部实现的时候,如不考虑子类,也往往会影响到子类
            [例子没有看]
                子类和父类之间是细节依赖,子类扩展父类,仅仅知道父类能做什么是不够的
                还需要知道父类是怎么做的
                而父类的实现细节也不能随意修改,否则可能会影响子类
                @@@子类需要知道父类的可重写方法之间的依赖关系,而且这个依赖关系,父类不能随意改变
                即使这个依赖关系不变,封装还是可能被破坏
                可以看出,父类不能随意增加公开方法,因为给父类增加就是给所有子类增加,
                而子类可能必须要重写该方法才能确保方法的正确性.
                [总结一下]
                    对于子类而言,通过继承实现是没有安全保障的,因为父类修改内部实现细节,
                    它的功能就会被破坏;
                    而对于基类而言,让子类继承和重写方法,就可能丧失随意修改内部实现的自由.
        [继承没有反映is-a关系]
            继承关系是设计用来反映is-a关系的,子类是父类的一种,子类对象也属于父类,
            父类的行为和属性也使用于子类
            继承是应该被当做is-a关系使用的.但是,java并没有办法约束,父类有的属性和行为,
            子类并不一定都适用,子类还可以重写方法,实现与父类预期完全不一样的行为
            但对于通过父类引用操作子类对象的程序而言,它是把对象当做父类对象来看待的,
            期望对象符合父类中声明的属性和行为.
        [如何应对继承的双面性]
            避免使用继承 or 正确使用继承
            避免使用继承的三种方法:
                使用final关键字
                优先使用组合而非继承
                使用接口
                [使用final避免继承]
                    我们提到过final类和final方法
                        final方法不能被重写
                        final类不能被继承
                    给方法加final修饰符,父类就保留了随意修改这个方法内部实现的自由
                    给类加final修饰符,父类就保留了随意修改这个类实现的自由
                [优先使用组合而非继承]
                    使用组合可以抵挡父类变化对子类的影响,从而保护子类,应该优先使用组合.
                    组合就是在子类中声明父类变量,再通过构造方法new出父类对象
                    组合的问题在于,子类对象不能当作基类对象来统一处理,解决的方法是接口
                [正确使用继承]
                    使用继承的三大场景:
                        基类是别人写的,我们写子类
                        我们写基类,别人写子类
                        基类/子类都是我们写的
                        [第一种场景]
                            基类主要使用的是java api/其他框架或类库中的类
                            在这种情况下,我们主要通过扩展基类来实现自定义行为
                            [注意点]
                                重写方法不要改变预期行为
                                阅读文档说明,理解可重写方法的实现机制,尤其是方法之间的依赖关系
                                在基类修改的情况下,阅读其修改说明,相应修改子类
                        [第二种场景]
                            我们写基类给别人用
                            [注意点]
                                使用继承反映真正的is-a关系,只将真正公共的部分放到基类
                                对不希望被重写的公开方法添加final修饰符
                                写文档,说明可重写方法的实现机制,为子类提供指导,告诉子类应该如何重写
                                在基类修改可能影响子类时,写修改说明
                        [第三种场景]
                            
                    