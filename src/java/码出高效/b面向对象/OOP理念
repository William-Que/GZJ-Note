两种理念:
    面向过程编程:结构相对松散,强调如何流程化的解决问题
    面向对象编程:强调高内聚,低耦合,先抽象模型,定义共性行为,再解决实际问题.
    
警示:编程语言仅是一个工具,就像练武之人的剑,武功高者草木皆剑,武功差者即使莫邪剑在身也依然平庸.
    优秀的开发工程师本身用面向过程的语言也能把程序写的非常内聚,可扩展性好,具备一定的复用性;
    平庸的程序员用面向对象语言一样能把程序写的松散随意,毫无抽象与建模,模块间耦合严重,维护性差.
    
面向对象的四大特征:封装/继承/多态/抽象
    抽象:抽象对业务的建模能力,以及对架构的宏观掌控能力
    封装:是一种对象功能内聚的表现形式,使模块之间耦合度变低,更具有维护性
    继承:使子类能够继承父类,获得父类的部分属性和行为,使模块更具有服用性
    多态:使模块在复用性的基础上更加有扩展性,使运行期更有想象空间

抽象分为归纳和演绎
    是封装/继承/多态的基础
    归纳:从具体到本质,从个性到共性,将一类对象的共同特征进行归一化的逻辑思维过程
    演绎:从本质到具体,从共性到个性,逐步形象化的过程
    归纳的难度大于演绎,需要抽象出对象的属性和行为的共性
    演绎是在已有的问题解决方案的基础上,正确地找到合适的使用场景
    演绎错误:在使用集合时,比如针对查多改少的业务场景,使用链表是非常不合理的;底层架构技术选型时,如果有错误,则有可能导致技术架构完全不适应业务的快速发展
    
object类
    任何类的默认父类,是对万事万物的抽象,是在哲学方向上进行的延伸思考,高度概括了事物的自然行为和社会行为
    我是谁?getClass()说明本质上是谁,而toString()是当前职位的名片
    我从哪里来?Object()构造方法是生产对象的基本步骤,clone()是繁殖对象的另一种方式
    我到哪里去?finalize()是在对象销毁时触发的方法
    
clone()方法
    浅拷贝,一般深拷贝和彻底深拷贝
    慎用Object的clone()方法,因为对象的clone()方法默认是浅拷贝,若想实现深拷贝,则需要覆写clone()方法实现引用对象的深度遍历式拷贝
        
世界是否因你而不同?hashCode()和equals()就是判断与其他元素是否相同的一组方法
与他人如何协调?wait()和notify()是对象间通信及协作的一组方法

封装
    封装是在抽象基础上决定信息是否公开,以及公开的等级,核心问题是以什么样的方式暴露哪些信息.抽象是要找到属性和行为的共性,属性是行为的基本生产资料,具有一定的敏感性,不能直接对外暴露
    封装的主要任务是对属性,数据,部分内部敏感行为实现隐藏.
    对属性的访问与修改必须通过定义的公共接口来进行,某些敏感方法或外部不需要感知的复杂逻辑处理,一般也会进行封装
    属性值的访问与修改需要使用相应的getter/setter方法,而不是直接对public的属性进行读取和修改
    
继承
    是面向对象编程技术的基石,允许创建具有逻辑等级结构的类体系,形成一个继承树,让软件在业务多变的客观条件下,某些基础模块可以被直接复用/间接复用/增强复用
    继承是is-a关系,判断标准即是符合里氏代换原则
    LSP是指任何父类能够出现的地方,子类都能够出现
    
方法污染和方法爆炸
    我们传递的理念是谨慎使用继承,认清继承使用的危害性,即方法污染和方法爆炸
    方法污染:是指父类具备的行为,通过继承传递给子类,子类并不具备执行此行为的能力,比如鸟会飞,鸵鸟继承鸟,发现飞不了,这就是方法污染
    子类继承父类,则说明子类对象可以调用父类对象的一切行为.在这样的情况下,总不能继承时,添加注释说明哪几个父类方法不能在子类中执行,更不能覆写这些无法执行的父类方法,抛出异常,以阻止别人的调用
    方法爆炸:是指继承树不断扩大,底层拥有的方法虽然都能够执行,但是由于方法众多,其中部分方法并非与当前类的功能定位相关,很容易在实际编程中产生选择困难症
    综上所述,提倡组合优先原则来扩展类的能力,即优先采用组合或聚合的类关系来复用其他类的能力,而不是继承
    
多态
    是以抽象,封装,继承三个面向对象的特性为基础,根据运行时的实际对象类型,同一个方法产生不同的运行结果,使同一个行为具有不同的表现形式
    多态专指覆写
    
override和overload
    override翻译成覆写,是子类实现接口,或者继承父类时,保持方法签名完全相同,实现不同的方法体,是垂直方向上行为的不同实现;jvm动态绑定
    不明白?!?overlord翻译成重载,方法名称是相同的,但是参数类型或参数个数是不同的,是水平方向上行为的不同实现;jvm静态绑定
    
    
    
        
    
    
