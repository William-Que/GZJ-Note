#设备层面的概述
    无论是图形图像的渲染/网络远程共享/大数据计算,归根结底都是0和1的信号处理.信息存储和逻辑计算的元数据,只能是0和1,但他们在不同介质里的物理表现方式却是不一样的,如三极管的断电和通电,cpu的低电平和高电平,磁盘的电荷左右方向.
    3.2-5.0v为高电平,0-0.3v为低电平;
    平时所说的32位机是指能够同时处理字长为32位电路信号;
#进制概述
    最左侧表示正负号,二进制整数最终都是以补码形式出现的,正数的补码与原码,反码是一样的;而负数的补码则是反码加1的结果.
    加减法是高频运算,使用同一个运算器,可以减少中间变量的存储开销,这样也降低了CPU内部的设计复杂度.
    图c,计算结果需要9条电路信号,用8条电路信号会出现溢出的状况,一旦溢出计算结果就是错误的.
    在上述所说的,一条电路信号是一个位,bit,简写为b;8个bit组成一个单位,称为字节,即1个byte,简写为B;1024个byte简写为1kb;1024个kb简写为1mb;1024个mb简写为GB;
#位移运算(确实复杂)
    在代码中进行高低位截取,哈希计算,甚至运用在乘除法运算中;
    向右移动1位近似表示除以2,十进制的奇数转化为二进制数后,在向右移动时,最右边的1将直接被抹去,说明向右移对于奇数来说并非完全相当于除以2;
    在左移和右移两种运算中,符号位均参与移动,除负数往右移,高位补1以外,其他情况均在空位处补0;
    P4--->需要抽时间理解
#位运算
    按位取反,按位或,按位与,按位异或;
    逻辑与,短路功能,有false就提前触发短路退出;
    逻辑或,短路功能,有true就提前触发短退出;
#真值/原码/反码/补码/移码
    在计算机系统中,数据一律用补码来运算及存储.
    [原因在于使用补码可以统一处理符号位及数值域,及真值的加减法]需要细想和论证
    
    https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html#!comments
    需要解决的地方:位移运算,真值原码反码补码移码
    计算机设计成加法,在电路设计上更为简单
    对于计算机来说,计算过程并没有正负之说,只是因为人类的数学计算历史要久于计算机的数学计算历史,所以才有这些问题产生
    [机器数]一个数在计算机硬件中,以二进制形式表示
    [真值]由于机器数的最高位为符号位,所以其转换为十进制的形式值并不等于实际的数值.
    [原码]人类可以直接标识的数值,可以直观感受到符号位的数值
    [反码]将符号位参与到运算中,并且只保留加法的设计原理,才会有了反码,但问题在于计算出的结果中数值为"0"的特殊性,对于人类来说+0和-0的概念是一样,但是对于机器来说,符号位本身就没有意义并且还多了两个编码
    [补码]补码解决了+0和-0的问题,并且不影响到计算结果,还多了一个位数-128
    [移码]
    

    

